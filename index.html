import sys
import requests
import time
import logging
import sqlite3
from datetime import datetime, timedelta
from PyQt6.QtWidgets import QApplication, QMainWindow, QTabWidget, QTableWidget, QTableWidgetItem, QVBoxLayout, QWidget, QLabel, QPushButton
from PyQt6.QtCore import Qt
import pandas as pd

# Setup logging to file and console with UTF-8 encoding
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('abou_dojo_log.txt', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

# Configuration
STARTGG_API_TOKEN = "e678b0af93f01489a7a1699b548a0a53"
STARTGG_API_URL = "https://api.start.gg/gql/alpha"
START_DATE = datetime(2024, 4, 1)  # Start from April 2024
END_DATE = datetime(2025, 4, 21)  # Current date
PER_PAGE = 50
MAX_RETRIES = 3
RETRY_DELAY = 5
CHUNK_DAYS = 30
MAX_EVENTS_PER_MONTH = 5  # Allow up to 5 Thursdays per month
DB_FILE = "abou_dojo.db"

# Points mapping based on placement
POINTS_TABLE = [
    (1, 50),   # 1st
    (2, 40),   # 2nd
    (3, 35),   # 3rd
    (4, 30),   # 4th
    (5, 25),   # 5th tied
    (7, 20),   # 7th tied
    (9, 15),   # 9th tied
    (13, 12),  # 13th tied
    (17, 10),  # 17th and beyond
]

# GraphQL Queries
TOURNAMENTS_QUERY = """
query TournamentsByDate($perPage: Int!, $page: Int, $afterDate: Timestamp, $beforeDate: Timestamp) {
  tournaments(query: {
    perPage: $perPage
    page: $page
    filter: {
      afterDate: $afterDate
      beforeDate: $beforeDate
    }
  }) {
    nodes {
      id
      name
      startAt
      isOnline
      countryCode
      city
      events {
        id
        name
        numEntrants
        videogame {
          id
          name
        }
      }
    }
    pageInfo {
      total
      totalPages
    }
  }
}
"""

ENTRANTS_QUERY = """
query EventEntrants($eventId: ID!, $page: Int, $perPage: Int) {
  event(id: $eventId) {
    entrants(query: {page: $page, perPage: $perPage}) {
      nodes {
        id
        name
        participants {
          player {
            id
            gamerTag
          }
        }
      }
      pageInfo {
        total
        totalPages
      }
    }
  }
}
"""

SETS_QUERY = """
query EventSets($eventId: ID!, $page: Int, $perPage: Int) {
  event(id: $eventId) {
    sets(page: $page, perPage: $perPage) {
      nodes {
        id
        winnerId
        slots {
          entrant {
            id
            name
          }
        }
      }
      pageInfo {
        total
        totalPages
      }
    }
    standings(query: {perPage: 48}) {
      nodes {
        placement
        entrant {
          id
          name
        }
      }
    }
  }
}
"""

def get_points_for_placement(placement):
    if placement is None:
        return 0
    for rank, points in POINTS_TABLE:
        if placement <= rank:
            return points
    return 10  # Default for 17th and beyond

def init_database():
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS tournaments (
                    tournament_id TEXT PRIMARY KEY,
                    name TEXT,
                    date INTEGER,
                    num_entrants INTEGER NOT NULL DEFAULT 0
                )
            """)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS player_records (
                    tournament_id TEXT,
                    player_id TEXT,
                    name TEXT NOT NULL,
                    match_wins INTEGER DEFAULT 0,
                    match_losses INTEGER DEFAULT 0,
                    placement INTEGER,
                    PRIMARY KEY (tournament_id, player_id),
                    FOREIGN KEY (tournament_id) REFERENCES tournaments(tournament_id)
                )
            """)
            conn.commit()
            logging.info("Database initialized successfully")
    except sqlite3.Error as e:
        logging.error(f"Error initializing database: {e}")
        raise

def get_latest_event_date():
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT MAX(date) FROM tournaments")
            result = cursor.fetchone()[0]
            if result:
                latest_date = datetime.fromtimestamp(result)
                days_to_thursday = (3 - latest_date.weekday() + 7) % 7
                if days_to_thursday == 0:  # If it's Thursday, use next Thursday
                    days_to_thursday = 7
                next_thursday = latest_date + timedelta(days=days_to_thursday)
                logging.info(f"Latest event date: {latest_date}, Next Thursday: {next_thursday}")
                return next_thursday
            logging.info("No events in database, using default start date")
            return START_DATE
    except sqlite3.Error as e:
        logging.error(f"Error querying latest event date: {e}")
        return START_DATE

def save_tournament_to_db(tournament):
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO tournaments (tournament_id, name, date, num_entrants)
                VALUES (?, ?, ?, ?)
            """, (
                tournament["id"],
                tournament["name"],
                int(tournament["date"].timestamp()),
                tournament["num_entrants"]
            ))
            for player_id, stats in tournament["player_records"].items():
                cursor.execute("""
                    INSERT OR REPLACE INTO player_records (tournament_id, player_id, name, match_wins, match_losses, placement)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    tournament["id"],
                    stats["player_id"],
                    stats["name"],
                    stats["match_wins"],
                    stats["match_losses"],
                    stats["placement"]
                ))
            conn.commit()
            logging.info(f"Saved tournament {tournament['id']} to database")
    except sqlite3.Error as e:
        logging.error(f"Error saving tournament {tournament['id']} to database: {e}")

def load_tournaments_from_db():
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM tournaments")
            tournaments = []
            for row in cursor.fetchall():
                tournament_id, name, date, num_entrants = row
                if num_entrants is None:
                    logging.error(f"num_entrants is None for tournament {tournament_id}, setting to 0")
                    num_entrants = 0
                cursor.execute("SELECT * FROM player_records WHERE tournament_id = ?", (tournament_id,))
                player_records = {}
                for pr_row in cursor.fetchall():
                    _, player_id, name, match_wins, match_losses, placement = pr_row
                    player_records[player_id] = {
                        "player_id": player_id,
                        "name": name,
                        "match_wins": match_wins if match_wins is not None else 0,
                        "match_losses": match_losses if match_losses is not None else 0,
                        "placement": placement
                    }
                tournaments.append({
                    "id": tournament_id,
                    "name": name,
                    "date": datetime.fromtimestamp(date),
                    "num_entrants": num_entrants,
                    "player_records": player_records
                })
            logging.info(f"Loaded {len(tournaments)} tournaments from database")
            return sorted(tournaments, key=lambda x: x["date"])
    except sqlite3.Error as e:
        logging.error(f"Error loading tournaments from database: {e}")
        return []

def fetch_startgg_data(query, variables, retries=MAX_RETRIES):
    headers = {"Authorization": f"Bearer {STARTGG_API_TOKEN}"}
    for attempt in range(retries):
        try:
            logging.debug(f"Fetching data with variables: {variables}")
            response = requests.post(STARTGG_API_URL, json={"query": query, "variables": variables}, headers=headers, timeout=10)
            logging.info(f"API request - Status: {response.status_code} (Attempt {attempt + 1}/{retries})")
            if response.status_code == 200:
                data = response.json()
                if "errors" in data:
                    logging.error(f"GraphQL errors: {data['errors']}")
                    return None
                return data.get("data", {})
            elif response.status_code == 429:
                delay = RETRY_DELAY * (2 ** attempt)
                logging.warning(f"Rate limited. Retrying in {delay} seconds...")
                time.sleep(delay)
            else:
                logging.error(f"Error {response.status_code}: {response.text[:100]}...")
                return None
        except requests.RequestException as e:
            logging.error(f"Request failed: {e}")
            if attempt < retries - 1:
                delay = RETRY_DELAY * (2 ** attempt)
                logging.info(f"Retrying in {delay} seconds...")
                time.sleep(delay)
    logging.error("Max retries reached")
    return None

def clean_player_name(name):
    if not name:
        return None
    name = name.encode('ascii', 'ignore').decode('ascii')
    for delimiter in ["|", "]", "-", ":"]:
        if delimiter in name:
            name = name.split(delimiter)[-1].strip()
    return name if name else None

def process_date_chunk(start_date, end_date):
    tournaments_data = []
    page = 1
    expected_thursdays = set()
    date_iter = start_date
    while date_iter <= end_date:
        if date_iter.weekday() == 3:  # Thursday
            expected_thursdays.add(date_iter.strftime('%Y-%m-%d'))
        date_iter += timedelta(days=1)

    logging.info(f"Looking for 'Abou Dojo' events on Thursdays: {sorted(expected_thursdays)}")

    while True:
        variables = {
            "perPage": PER_PAGE,
            "page": page,
            "afterDate": int(start_date.timestamp()),
            "beforeDate": int(end_date.timestamp())
        }
        try:
            data = fetch_startgg_data(TOURNAMENTS_QUERY, variables)
            if not data or not data.get("tournaments", {}).get("nodes"):
                logging.info(f"No more data at page {page} for {start_date.date()} to {end_date.date()}")
                break

            tournaments = data["tournaments"]["nodes"]
            total_pages = data["tournaments"]["pageInfo"]["totalPages"]
            logging.info(f"Processing page {page}/{total_pages}: Found {len(tournaments)} tournaments")

            for tournament in tournaments:
                tournament_name = tournament["name"].lower()
                if "abou dojo" not in tournament_name:
                    continue

                date = tournament.get("startAt", int(time.time()))
                tournament_date = datetime.fromtimestamp(date)
                date_str = tournament_date.strftime('%Y-%m-%d')
                if tournament_date.weekday() != 3:  # Thursday
                    logging.info(f"Skipping {tournament['name']}: Not on Thursday (Date: {tournament_date.strftime('%Y-%m-%d %A')})")
                    continue

                tournament_id = f"startgg_{tournament['id']}"
                logging.info(f"Found Abou Dojo tournament: {tournament['name']} (ID: {tournament_id}, Date: {date_str})")

                num_entrants = max([e["numEntrants"] for e in tournament.get("events", []) if e["numEntrants"]], default=0)
                event = tournament["events"][0]  # Take the first event
                if not event.get("id"):
                    logging.warning(f"No valid event in {tournament_id}")
                    continue

                event_id = event["id"]
                logging.info(f"Processing event {event_id} in {tournament_id}: {event['name']} ({num_entrants} entrants)")

                # Fetch entrants
                all_entrants = []
                entrant_page = 1
                while True:
                    entrant_data = fetch_startgg_data(ENTRANTS_QUERY, {"eventId": event_id, "page": entrant_page, "perPage": PER_PAGE})
                    if not entrant_data:
                        logging.warning(f"No entrant data for event {event_id}. Response: {entrant_data}")
                        break
                    if not entrant_data.get("event", {}).get("entrants", {}).get("nodes"):
                        logging.warning(f"No entrant nodes for event {event_id}. Response: {entrant_data.get('event', {})}")
                        break
                    all_entrants.extend(entrant_data["event"]["entrants"]["nodes"])
                    if entrant_page >= entrant_data["event"]["entrants"]["pageInfo"]["totalPages"]:
                        break
                    entrant_page += 1
                    time.sleep(1)

                if not all_entrants:
                    logging.warning(f"Skipping event {event_id}: No entrants fetched")
                    continue

                # Fetch sets and standings
                all_sets = []
                standings = []
                set_page = 1
                while True:
                    set_data = fetch_startgg_data(SETS_QUERY, {"eventId": event_id, "page": set_page, "perPage": PER_PAGE})
                    if not set_data or not set_data.get("event", {}).get("sets", {}).get("nodes"):
                        break
                    all_sets.extend(set_data["event"]["sets"]["nodes"])
                    standings = set_data["event"].get("standings", {}).get("nodes", []) if set_data["event"].get("standings") else []
                    if set_page >= set_data["event"]["sets"]["pageInfo"]["totalPages"]:
                        break
                    set_page += 1
                    time.sleep(1)

                if not all_sets:
                    logging.warning(f"Skipping event {event_id}: No sets fetched")
                    continue

                # Handle 2v2: Map entrants to players
                entrant_to_players = {}
                for entrant in all_entrants:
                    entrant_id = str(entrant["id"])
                    participants = entrant.get("participants", [])
                    player_ids = []
                    player_names = []
                    for participant in participants:
                        player = participant.get("player")
                        if player:
                            player_id = str(player["id"])
                            player_name = clean_player_name(player.get("gamerTag", entrant.get("name", "")))
                            if player_name:
                                player_ids.append(player_id)
                                player_names.append(player_name)
                    if not player_ids:
                        logging.warning(f"No valid players for entrant {entrant_id} in tournament {tournament_id}")
                        continue
                    entrant_to_players[entrant_id] = {
                        "player_ids": player_ids,
                        "player_names": player_names
                    }

                # Initialize player records
                player_records = {}
                for entrant_id, info in entrant_to_players.items():
                    for player_id, player_name in zip(info["player_ids"], info["player_names"]):
                        player_records[player_id] = {
                            "player_id": player_id,
                            "name": player_name,
                            "match_wins": 0,
                            "match_losses": 0,
                            "placement": None
                        }

                # Record placements from standings
                for standing in standings:
                    entrant = standing.get("entrant")
                    if not entrant:
                        continue
                    entrant_id = str(entrant["id"])
                    player_info = entrant_to_players.get(entrant_id)
                    if not player_info:
                        continue
                    placement = standing.get("placement")
                    for player_id in player_info["player_ids"]:
                        if player_id in player_records:
                            player_records[player_id]["placement"] = placement

                # Process sets to calculate match wins/losses
                for match_set in all_sets:
                    slots = match_set.get("slots", [])
                    if len(slots) != 2 or not slots[0]["entrant"] or not slots[1]["entrant"]:
                        continue

                    p1_entrant_id, p2_entrant_id = str(slots[0]["entrant"]["id"]), str(slots[1]["entrant"]["id"])
                    p1_info = entrant_to_players.get(p1_entrant_id)
                    p2_info = entrant_to_players.get(p2_entrant_id)
                    if not p1_info or not p2_info:
                        continue

                    winner_id = str(match_set["winnerId"]) if match_set.get("winnerId") else None
                    if not winner_id:
                        continue

                    if winner_id == p1_entrant_id:
                        for player_id in p1_info["player_ids"]:
                            if player_id in player_records:
                                player_records[player_id]["match_wins"] += 1
                        for player_id in p2_info["player_ids"]:
                            if player_id in player_records:
                                player_records[player_id]["match_losses"] += 1
                    elif winner_id == p2_entrant_id:
                        for player_id in p2_info["player_ids"]:
                            if player_id in player_records:
                                player_records[player_id]["match_wins"] += 1
                        for player_id in p1_info["player_ids"]:
                            if player_id in player_records:
                                player_records[player_id]["match_losses"] += 1

                logging.info(f"Processed {len(player_records)} players for {tournament_id}")
                tournament_data = {
                    "id": tournament_id,
                    "name": tournament["name"],
                    "date": tournament_date,
                    "num_entrants": num_entrants,
                    "player_records": player_records
                }
                tournaments_data.append(tournament_data)
                save_tournament_to_db(tournament_data)

                if date_str in expected_thursdays:
                    expected_thursdays.remove(date_str)

        except Exception as e:
            logging.error(f"Error processing page {page}: {e}", exc_info=True)
            break

        page += 1
        if page > total_pages:
            break
        time.sleep(1)

    if expected_thursdays:
        logging.warning(f"No 'Abou Dojo' events found for the following Thursdays: {sorted(expected_thursdays)}")

    logging.info(f"Total tournaments processed in this chunk: {len(tournaments_data)}")
    return tournaments_data

class AbouDojoRankings(QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.setWindowTitle("Abou Dojo Cumulative Monthly Rankings")
            self.setGeometry(100, 100, 900, 600)

            main_widget = QWidget()
            self.setCentralWidget(main_widget)
            layout = QVBoxLayout()
            main_widget.setLayout(layout)

            self.tabs = QTabWidget()
            layout.addWidget(self.tabs)

            self.populate_tabs()
        except Exception as e:
            logging.error(f"Error initializing GUI: {e}", exc_info=True)
            raise

    def populate_tabs(self):
        try:
            init_database()
            tournaments_data = load_tournaments_from_db()

            fetch_start_date = get_latest_event_date()
            if fetch_start_date < END_DATE:
                logging.info(f"Fetching new data from {fetch_start_date.date()} to {END_DATE.date()}")
                current_start = fetch_start_date
                while current_start < END_DATE:
                    current_end = min(current_start + timedelta(days=CHUNK_DAYS), END_DATE)
                    logging.info(f"Fetching chunk: {current_start.date()} to {current_end.date()}")
                    chunk_data = process_date_chunk(current_start, current_end)
                    tournaments_data.extend(chunk_data)
                    current_start = current_end + timedelta(seconds=1)
                    time.sleep(2)
            else:
                logging.info("No new data to fetch; using database only")

            if not tournaments_data:
                logging.warning("No Abou Dojo events found in database or API")
                self.tabs.addTab(QLabel("No Abou Dojo events found"), "No Data")
                return

            earliest_date = min(tournament["date"] for tournament in tournaments_data)
            all_months = []
            current_date = earliest_date.replace(day=1)
            while current_date <= END_DATE:
                month_key = current_date.strftime("%B %Y")
                if month_key not in all_months:
                    all_months.append(month_key)
                current_date = (current_date.replace(day=1) + timedelta(days=32)).replace(day=1)

            months = {month: {"events": [], "player_records": {}, "total_entrants": 0} for month in all_months}
            for tournament in tournaments_data:
                month_key = tournament["date"].strftime("%B %Y")
                if month_key not in months:
                    months[month_key] = {"events": [], "player_records": {}, "total_entrants": 0}
                months[month_key]["events"].append(tournament)
                num_entrants = tournament["num_entrants"]
                if num_entrants is None:
                    logging.error(f"num_entrants is None for tournament {tournament['id']} in month {month_key}, setting to 0")
                    num_entrants = 0
                months[month_key]["total_entrants"] += num_entrants

                for player_id, stats in tournament["player_records"].items():
                    if player_id not in months[month_key]["player_records"]:
                        months[month_key]["player_records"][player_id] = {
                            "name": stats["name"],
                            "match_wins": 0,
                            "match_losses": 0,
                            "placements": [None] * MAX_EVENTS_PER_MONTH
                        }
                    event_index = len(months[month_key]["events"]) - 1
                    if event_index < MAX_EVENTS_PER_MONTH:
                        months[month_key]["player_records"][player_id]["placements"][event_index] = stats["placement"]
                    else:
                        logging.warning(f"Event index {event_index} exceeds max events ({MAX_EVENTS_PER_MONTH}) for {month_key}")
                    months[month_key]["player_records"][player_id]["match_wins"] += stats["match_wins"]
                    months[month_key]["player_records"][player_id]["match_losses"] += stats["match_losses"]

            logging.info(f"Months with data: {list(months.keys())}")
            for month in all_months:
                if month not in months:
                    months[month] = {"events": [], "player_records": {}, "total_entrants": 0}
                data = months[month]
                tab = QWidget()
                tab_layout = QVBoxLayout()
                tab.setLayout(tab_layout)

                rankings = []
                for player_id, stats in data["player_records"].items():
                    total_matches = stats["match_wins"] + stats["match_losses"]
                    win_rate = (stats["match_wins"] / total_matches * 100) if total_matches > 0 else 0
                    placements = stats["placements"][:len(data["events"])]
                    total_points = sum(get_points_for_placement(p) for p in placements if p is not None)
                    events_entered = sum(1 for p in placements if p is not None)
                    per_event_rankings = "/".join(str(p) if p is not None else "-" for p in placements)
                    logging.debug(f"Player {stats['name']} in {month}: Placements {placements}, Points {total_points}, Matches Won {stats['match_wins']}, Matches Lost {stats['match_losses']}, Win Rate {win_rate:.2f}%")
                    rankings.append({
                        "player_name": stats["name"],
                        "match_wins": stats["match_wins"],
                        "match_losses": stats["match_losses"],
                        "win_rate": win_rate,
                        "per_event_rankings": per_event_rankings,
                        "total_points": total_points,
                        "events_entered": events_entered
                    })

                if not rankings:
                    logging.warning(f"No rankings for {month}")
                    tab_layout.addWidget(QLabel("No player data available"))
                    self.tabs.addTab(tab, month)
                    continue

                rankings = sorted(rankings, key=lambda x: (-x["total_points"], -x["events_entered"], -x["match_wins"]))
                for i, ranking in enumerate(rankings):
                    ranking["placement"] = i + 1

                logging.info(f"Rankings for {month}: {len(rankings)} players")
                table = QTableWidget()
                table.setRowCount(len(rankings))
                table.setColumnCount(7)
                table.setHorizontalHeaderLabels(["Player", "Placement", "Total Points", "Matches Won", "Matches Lost", "Win Rate (%)", "Per-Event Rankings"])

                for row, ranking in enumerate(rankings):
                    table.setItem(row, 0, QTableWidgetItem(ranking["player_name"]))
                    table.setItem(row, 1, QTableWidgetItem(str(ranking["placement"])))
                    table.setItem(row, 2, QTableWidgetItem(str(ranking["total_points"])))
                    table.setItem(row, 3, QTableWidgetItem(str(ranking["match_wins"])))
                    table.setItem(row, 4, QTableWidgetItem(str(ranking["match_losses"])))
                    table.setItem(row, 5, QTableWidgetItem(f"{ranking['win_rate']:.2f}"))
                    table.setItem(row, 6, QTableWidgetItem(ranking["per_event_rankings"]))

                table.resizeColumnsToContents()
                table.setAlternatingRowColors(True)
                table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)

                event_count = len(data["events"])
                total_entrants = data["total_entrants"]
                tab_layout.addWidget(QLabel(f"<b>{month}</b> ({event_count} events, {total_entrants} total entrants)"))

                export_button = QPushButton("Export to Excel")
                month_name, year = month.split()
                export_filename = f"Rankings_{month_name}_{year}.xlsx"
                export_button.clicked.connect(lambda checked, r=rankings, fn=export_filename: self.export_to_excel(r, fn))
                tab_layout.addWidget(export_button)

                tab_layout.addWidget(table)
                self.tabs.addTab(tab, month)
        except Exception as e:
            logging.error(f"Error populating tabs: {e}", exc_info=True)
            self.tabs.addTab(QLabel(f"Error loading data: {str(e)}"), "Error")
            return

    def export_to_excel(self, rankings, filename):
        try:
            export_data = []
            for ranking in rankings:
                export_data.append({
                    "player": ranking["player_name"],
                    "placement": ranking["placement"],
                    "total points": ranking["total_points"],
                    "matches won": ranking["match_wins"],
                    "matches lost": ranking["match_losses"],
                    "win rate (%)": f"{ranking['win_rate']:.2f}",
                    "per event rankings": ranking["per_event_rankings"],
                    "events entered": ranking["events_entered"]
                })
            df = pd.DataFrame(export_data)
            df.to_excel(filename, index=False)
            logging.info(f"Exported rankings to {filename}")
        except Exception as e:
            logging.error(f"Error exporting to Excel: {e}")
            self.tabs.addTab(QLabel(f"Error exporting to Excel: {str(e)}"), "Export Error")

def main():
    try:
        app = QApplication(sys.argv)
        window = AbouDojoRankings()
        window.show()
        sys.exit(app.exec())
    except Exception as e:
        logging.error(f"Error in main: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()
